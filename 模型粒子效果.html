<!--
 * @Description: 
 * @Author: zhh_e
 * @Date: 2023-04-13 11:09:02
 * @LastEditors: zhh_e
 * @LastEditTime: 2023-04-13 18:05:12
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模型粒子效果</title>
</head>
<style>
    body {
        margin: 0
    }
</style>

<body>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from "three"
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from "three/addons/libs/stats.module.js"
        import { GUI } from "three/addons/libs/lil-gui.module.min.js"
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js"
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // import gsap from "./js/gsap.min.js"

        class ParticleEffect {
            pointNumber
            particle
            bufferGeometry
            material
            toPosition
            speed
            color
            toColor
            scale
            constructor(pointNumber = 50000) {
                this.pointNumber = pointNumber
                this.positions = new Float32Array(pointNumber * 3)

                this.bufferGeometry = new THREE.BufferGeometry()
                this.bufferGeometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3))

                this.toPosition = new Float32Array(pointNumber * 3)
                this.bufferGeometry.setAttribute('toPosition', new THREE.BufferAttribute(this.toPosition, 3))

                this.speed = new Float32Array(pointNumber)
                this.bufferGeometry.setAttribute('speed', new THREE.BufferAttribute(this.speed, 1))

                this.color = new Float32Array(pointNumber * 3)
                this.bufferGeometry.setAttribute('color', new THREE.BufferAttribute(this.color, 3))

                this.toColor = new Float32Array(pointNumber * 3)
                this.bufferGeometry.setAttribute('toColor', new THREE.BufferAttribute(this.toColor, 3))

                this.scale = new Float32Array(pointNumber)
                this.bufferGeometry.setAttribute('scale', new THREE.BufferAttribute(this.scale, 1))

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        progress: { value: 1 }
                    },
                    vertexShader: `
                        uniform float progress;
                        attribute float speed;
                        attribute vec3 toPosition;
                        attribute vec3 color;
                        attribute vec3 toColor;
                        attribute float scale;
                        varying vec3 vColor;
                        void main() {
                            
                            vec3 dis = toPosition - position;
                            vec3 disColor = toColor - color;

                            float percent = progress / speed;
                            vec3 pos;
                            if(percent <= 1.0) {
                                pos = position + dis * percent;
                                vColor = color + disColor * percent;
                            }else{
                                pos = toPosition;
                                vColor = toColor;
                            }
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = scale;
                            gl_PointSize *=  200.0 / - (modelViewMatrix * vec4(pos, 1.0)).z;
                            
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        void main() {
                            float strength = distance(gl_PointCoord, vec2(0.5));
                            float dis = length(gl_PointCoord.xy - 0.5);
                            dis = smoothstep(0.5, 0.0, dis);
                            strength = step(0.5, strength);
                            strength = 1.0 - strength;

                            //圆形以外像素 不渲染
                            if(strength == 0.0)
                                discard;
                            if(dis == 0.0)
                                discard;
                            
                            gl_FragColor = mix(vec4(vec3(0.2,0.4,0.9),1.0), vec4(vColor,1.0), 0.9 );
                        }
                    `,
                    transparent: true,


                })

                this.particle = new THREE.Points(
                    this.bufferGeometry,
                    this.material
                )
                this.init()
            }
            setProgress(value) {
                this.material.uniforms.progress.value = value
            }
            init() {
                for (let i = 0; i < this.pointNumber; i++) {
                    this.toPosition[i * 3] = Math.random() * 30 - 15
                    this.toPosition[i * 3 + 1] = Math.random() * 30 - 15
                    this.toPosition[i * 3 + 2] = Math.random() * 30 - 15

                    this.toColor[i * 3] = Math.random()
                    this.toColor[i * 3 + 1] = Math.random()
                    this.toColor[i * 3 + 2] = Math.random()

                    this.scale[i] = 0.1 + Math.random() * 0.5;
                    this.speed[i] = Math.random() * 0.5 + 0.5
                }
                this.bufferGeometry.attributes.toPosition.needsUpdate = true
                this.bufferGeometry.attributes.toColor.needsUpdate = true
                this.bufferGeometry.attributes.speed.needsUpdate = true
                this.bufferGeometry.attributes.scale.needsUpdate = true
            }
            to(geometry, color) {
                const { array, count } = geometry.getAttribute('position')
                let targetIndex = 0
                for (let i = 0; i < this.pointNumber; i++) {
                    targetIndex %= count
                    this.positions[i * 3] = this.toPosition[i * 3]
                    this.positions[i * 3 + 1] = this.toPosition[i * 3 + 1]
                    this.positions[i * 3 + 2] = this.toPosition[i * 3 + 2]

                    this.toPosition[i * 3] = array[targetIndex * 3]
                    this.toPosition[i * 3 + 1] = array[targetIndex * 3 + 1]
                    this.toPosition[i * 3 + 2] = array[targetIndex * 3 + 2]

                    this.color[i * 3] = this.toColor[i * 3]
                    this.color[i * 3 + 1] = this.toColor[i * 3 + 1]
                    this.color[i * 3 + 2] = this.toColor[i * 3 + 2]

                    this.toColor[i * 3] = color ? color.r : Math.random()
                    this.toColor[i * 3 + 1] = color ? color.g : Math.random()
                    this.toColor[i * 3 + 2] = color ? color.b : Math.random()

                    this.speed[i] = Math.random() * 0.5 + 0.5
                    targetIndex++
                }
                this.bufferGeometry.attributes.position.needsUpdate = true
                this.bufferGeometry.attributes.toPosition.needsUpdate = true
                this.bufferGeometry.attributes.speed.needsUpdate = true
                this.bufferGeometry.attributes.color.needsUpdate = true
                this.bufferGeometry.attributes.toColor.needsUpdate = true
            }
        }

        let scene, camera, orbControls, renderer, axesHelper, stats, gui
        let particleEffectIns
        let guiParams = {
            shape: 'sphere',
            progress: 0
        }

        let people, worm_Gear, wall, HoneyComb

        init()
        animate()
        async function init() {
            initScene()
            initCamera()
            initRenderer()
            initOrbControls()
            initAxis()
            initStats()
            particleEffectIns = new ParticleEffect(50000)
            scene.add(particleEffectIns.particle)

            initGUI()

            const gltf = await loadGltf("./gltf/particle1.glb")
            console.log(' ====> gltf', gltf);
            const gScene = gltf.scene

            people = gScene.getObjectByName("people")
            worm_Gear = gScene.getObjectByName('Worm_Gear')
            wall = gScene.getObjectByName('Wall')
            HoneyComb = gScene.getObjectByName('HoneyComb')

            particleEffectIns.to(wall.geometry, new THREE.Color(0.2, 0.4, 0.9))

        }
        function initScene() {
            scene = new THREE.Scene()
        }
        function initCamera() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
            camera.position.set(50, 50, 70)
        }
        function initRenderer() {
            renderer = new THREE.WebGLRenderer()
            renderer.setSize(window.innerWidth, window.innerHeight)
            renderer.setPixelRatio(window.devicePixelRatio)
            document.body.appendChild(renderer.domElement)
        }
        function initOrbControls() {
            orbControls = new OrbitControls(camera, renderer.domElement)
        }
        function initAxis() {
            axesHelper = new THREE.AxesHelper(50)
            scene.add(axesHelper);
        }
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        function initGUI() {
            gui = new GUI()

            gui.add(guiParams, 'shape', ['sphere', 'box']).onChange((value) => {
                switch (value) {
                    case 'sphere':
                        guiParams.progress = 0
                        particleEffectIns.to(worm_Gear.geometry, new THREE.Color(0.6, 0.4, 0.9))
                        // particleEffectIns.to(new THREE.SphereGeometry(30, 64, 64), new THREE.Color(0.2, 0.4, 0.9))
                        break;
                    case 'box':
                        guiParams.progress = 0
                        particleEffectIns.to(people.geometry, new THREE.Color(0.9, 0.4, 0.2))
                        // particleEffectIns.to(new THREE.BoxGeometry(30, 30, 30, 20, 20, 20), new THREE.Color(0.9, 0.4, 0.2))
                        break;
                    default:
                        break;
                }
            })
        }
        function animate() {
            requestAnimationFrame(animate)
            renderer.render(scene, camera)
            stats.update()
            guiParams.progress += 0.01
            if (guiParams.progress >= 1) guiParams.progress = 1
            particleEffectIns.setProgress(guiParams.progress)
        }
        async function loadGltf(path) {
            let loader = new GLTFLoader();
            let dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('./js/jsm/libs/draco/gltf/');
            loader.setDRACOLoader(dracoLoader);
            return loader.loadAsync(path);
        }

    </script>
</body>

</html>